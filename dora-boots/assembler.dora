class AssemblerBuffer {
    let buffer: Vec[Byte] = Vec[Byte]();
    let slow_paths: Vec[SlowPath] = Vec[SlowPath]();

    fun emitByte(value: Byte) {
        self.buffer.push(value);
    }

    fun emitInt(value: Int) {
        self.emitByte((value & 0xFF).toByte);
        self.emitByte(((value >>> 8) & 0xFF).toByte);
        self.emitByte(((value >>> 16) & 0xFF).toByte);
        self.emitByte(((value >>> 24) & 0xFF).toByte);
    }

    fun addSlowPath(slow_path: SlowPath) {
        self.slow_paths.push(slow_path);
    }

    fun length -> Int {
        self.buffer.length
    }

    fun capacity() -> Int {
        self.buffer.capacity()
    }

    fun toArray() -> Array[Byte] {
        self.buffer.toArray()
    }
}

@test fun testAssemblerBufferEmitByte(_x: Testing) {
    let buffer = AssemblerBuffer();
    buffer.emitByte(0x01Y);
    buffer.emitByte(0x02Y);
    assert(buffer.length == 2);
}

@test fun testAssemblerBufferEmitInt(_x: Testing) {
    let asm = AssemblerBuffer();
    asm.emitInt(0x11223344);
    let buffer = asm.toArray();
    assert(buffer(0) == 0x44Y);
    assert(buffer(1) == 0x33Y);
    assert(buffer(2) == 0x22Y);
    assert(buffer(3) == 0x11Y);
    assert(buffer.length == 4);
}

@open @abstract class SlowPath {
    @abstract fun emit(asm: Assembler);
}

@open @abstract class Assembler

class Register(let value: Int) {
    fun lowBits() -> Int {
        self.value & 0b111
    }

    fun needsRexBit() -> Bool {
        self.value > 7
    }

    fun equals(rhs: Register) -> Bool {
        self.value == rhs.value
    }
}

class Immediate(let value: Long) {
    fun isInt8() -> Bool {
        self.value >= -128L && self.value <= 127L
    }

    fun isByte() -> Bool {
        self.value >= Byte::minValue().toLong && self.value <= Byte::maxValue().toLong
    }

    fun isInt() -> Bool {
        self.value >= Int::minValue().toLong && self.value <= Int::maxValue().toLong
    }

    fun toByte -> Byte {
        self.value.toByte
    }

    fun toInt -> Int {
        self.value.toInt
    }

    fun toLong -> Long {
        self.value
    }
}

fun asm1(buffer: Array[Byte], index: Int, val: Byte) {
    if buffer(index) != val {
        println("expected ${val.toStringHex()} but got ${buffer(index).toStringHex()}")
    }
    assert(buffer(index) == val);
}

fun asm2(buffer: Array[Byte], index: Int, val1: Byte, val2: Byte) {
    if buffer(index) != val1 || buffer(index+1) != val2 {
        println("expected ${val1.toStringHex()} ${val2.toStringHex()} but got ${buffer(index).toStringHex()} ${buffer(index+1).toStringHex()}")
    }
    assert(buffer(index) == val1 && buffer(index+1) == val2);
}

fun asm3(buffer: Array[Byte], index: Int, val1: Byte, val2: Byte, val3: Byte) {
    if buffer(index) != val1 || buffer(index+1) != val2 || buffer(index+2) != val3 {
        println("expected ${val1.toStringHex()} ${val2.toStringHex()} ${val3.toStringHex()} but got ${buffer(index).toStringHex()} ${buffer(index+1).toStringHex()} ${buffer(index+2).toStringHex()}")
    }
    assert(buffer(index) == val1 && buffer(index+1) == val2 && buffer(index+2) == val3);
}

fun asm4(buffer: Array[Byte], index: Int, val1: Byte, val2: Byte, val3: Byte, val4: Byte) {
    if buffer(index) != val1 || buffer(index+1) != val2 || buffer(index+2) != val3 || buffer(index+3) != val4 {
        println("expected ${val1.toStringHex()} ${val2.toStringHex()} ${val3.toStringHex()} ${val4.toStringHex()} but got ${buffer(index).toStringHex()} ${buffer(index+1).toStringHex()} ${buffer(index+2).toStringHex()} ${buffer(index+3).toStringHex()}")
    }
    assert(buffer(index) == val1 && buffer(index+1) == val2 && buffer(index+2) == val3 && buffer(index+3) == val4);
}

fun asmInt(buffer: Array[Byte], index: Int, value: Int) {
    assert(buffer(index) == (value & 0xFF).toByte);
    assert(buffer(index+1) == ((value >>> 8) & 0xFF).toByte);
    assert(buffer(index+2) == ((value >>> 16) & 0xFF).toByte);
    assert(buffer(index+3) == ((value >>> 24) & 0xFF).toByte);
}

fun printBuffer(buffer: Array[Byte]) {
    var i = 0;

    while i < buffer.length {
        let val = buffer(i);
        if i > 0 { print(" "); }
        print(intToHexString(val.toInt, 2));
        i = i + 1;
    }
}

fun intToHexString(var val: Int, padding: Int) -> String {
    var result = "";

    while val != 0 {
        let digit = val & 0xF;
        val = val >>> 4;

        let digit = if digit < 10 {
            (48 + digit).toChar().unwrap()
        } else {
            (65 + digit - 10).toChar().unwrap()
        };

        result = "${digit}${result}";
    }

    if result.isEmpty {
        result = "0";
    }

    while result.length < padding {
        result = "0${result}";
    }

    return result;
}